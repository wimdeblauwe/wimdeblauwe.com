---
title: "Port of the Laravel Intermediate Task List tutorial to Spring Boot with Thymeleaf"
date: 2020-02-17
draft: true
tags: ["thymeleaf", "spring-boot", "laravel"]
---
:source-highlighter: rouge
:rouge-css: style
:rouge-style: github
:imagesdir: /images
:icons: font
:toc: macro
:numbered:
:table-caption!:

https://laravel.com/[Laravel] is a very interesting PHP framework for building web applications.
Their docs have https://laravel.com/docs/5.2/quickstart-intermediate[a nice tutorial] to build a task list to explain many of their concepts.
This blog post basically mirrors that tutorial but shows how to build the same web application using https://spring.io/projects/spring-boot[Spring Boot] and https://www.thymeleaf.org/[Thymeleaf].

<!--more-->

toc::[]

== Installation

=== Prerequisites

The preferred way to install Laravel is to use composer.
For our Spring Boot port, we will be using http://maven.apache.org/[Maven] as our build tool.

Installation of Java and Maven on macOS is very easy if you use https://sdkman.io/[SDKMAN!].
Follow the installation instructions at https://sdkman.io/install to get started.

* Install Java:
+
[source]
----
sdk install java 11.0.5.hs-adpt
----
* Install Maven
+
[source]
----
sdk install maven
----

We need to specify a version for Java since we want to have the current LTS (Long Term Support) version which is 11 at the time of writing.
For Maven, we can just get the latest one (3.6.3 at the time of writing)

To check if both are installed correctly, run:

[source]
----
> mvn --version
Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)
Maven home: /Users/wdb/.sdkman/candidates/maven/current
Java version: 11.0.5, vendor: AdoptOpenJDK, runtime: /Users/wdb/.sdkman/candidates/java/11.0.5.hs-adpt
Default locale: en_BE, platform encoding: UTF-8
OS name: "mac os x", version: "10.15.3", arch: "x86_64", family: "mac"
----

=== Spring installation

With Laravel, the project is created using the following command:

[source]
----
composer create-project laravel/laravel quickstart --prefer-dist
----

Spring Boot has no such command.
Instead, a project is generated via https://start.spring.io.
Open that web page and select the following options:

[cols="20,20,60"]
|===
|Option |Value|Description

|Project
|Maven
|Allows to select the build tool to use. The 2 most widely used options are Maven and Gradle.

|Language
|Java
|Java code runs on the JVM (Java Virtual Machine).
However, there are also other languages that run in the same environment.
https://kotlinlang.org/[Kotlin] and http://groovy-lang.org/[Groovy] are other options that are possible.

|Spring Boot
|2.2.4
|Selection of the Spring Boot version to use.
This also defines what compatible versions of dependencies that will be used.

|Project Metadata
a|* GroupId: `com.wimdeblauwe.examples`
* ArtifactId: `laravel-intermediate-task-list`
|The `groupId:artifactId` defines the "name" of the project.
Don't worry about this too much now, you can always change it later.

|Options
|Java 11
|The "Options" item hides some more advanced options.
For now, the most important to select "Java 11" since that is the version of Java we want to use.

|Dependencies
|Spring Web, Thymeleaf, Spring Data JPA, Flyway Migration, Spring Security
a|Spring Boot is a very modular system.
When creating our project, we need to specify which modules we want to use.
In this case, we need to following 4 modules:

* Spring Web: Web server and routing
* Thymeleaf: HTML templating (similar to Blade)
* Spring Data JPA: Database access (similar to Eloquent)
* Flyway Migration: Database migrations
* Spring Security: Application security
|===

When everything is correctly selected, the page should look similar to this:

image::{imagesdir}/2020/02/laravel-intermediate-task-list-01.png[]

Press the 'Generate' button and a zip file with your project will be downloaded.
Unzip the project and open it in your favorite IDE (I use https://www.jetbrains.com/idea/[IntelliJ IDEA])

== Prepping the database

=== Database migrations

Laravel uses the Artisan CLI to generate PHP code that defines the database migration.
With Spring Boot, we will be using https://flywaydb.org/[Flyway].

Most important differences:

* Flyway uses plain SQL script to define the migrations (although you can use Java classes as well if you want)
* There is no code to reverse the migrations (like the `down()` method in Laravel migrations) by default.
It is possible with https://flywaydb.org/download/[Flyway Pro] to use https://flywaydb.org/documentation/migrations#undo-migrations[Undo Migrations] if you require this.

Spring Boot assumes Flyway migrations are put in `src/main/resources/db/migration` by default.

After creating those directories, we can add our first migration file:

.V1.0__init.sql
[source,sql]
----
CREATE TABLE task_user
(
    id       SERIAL       NOT NULL,
    name     VARCHAR(255) NOT NULL,
    email    VARCHAR(255) NOT NULL,
    password VARCHAR(255) NOT NULL,
    PRIMARY KEY (id)
);

CREATE TABLE task
(
    id      SERIAL       NOT NULL,
    user_id SERIAL       NOT NULL,
    name    VARCHAR(255) NOT NULL,
    PRIMARY KEY (id)
);

ALTER TABLE task
    ADD CONSTRAINT FK_task_to_user FOREIGN KEY (user_id) REFERENCES task_user;
----

See the https://flywaydb.org/documentation/migrations#naming[Naming] chapter in the Flyway documentation for more information
about how the name of the SQL file influences the order of the migrations.

[NOTE]
====
We are using `SERIAL` to get auto-incremented primary keys.
This is easiest now to get started, but it https://vladmihalcea.com/postgresql-serial-column-hibernate-identity/[might not always be the most performant option].
====

The database for this application will be https://www.postgresql.org/[PostgreSQL].
Java needs a JDBC driver to talk to the database.

We can add the PostgreSQL driver by adding a dependency in the `pom.xml` file that was generated by the Spring Boot website.
Go to https://start.spring.io again and go straight for the "Dependencies" section.
Type "PostgreSQL" and select the "PostgreSQL Driver" dependency that pops up.
Now use the 'Explore' button to view the `pom.xml` that would be generated if we would create a project.
In the popup, you will find the dependency section:

[source,xml]
----
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>
----

Add this XML snippet to your own `pom.xml` inside the `<dependencies>` node.

[NOTE]
====
There is no need to specify a version for the dependency, because Spring Boot handles this for us via the `spring-boot-starter-parent` parent.
See https://www.baeldung.com/spring-boot-starter-parent[The Spring Boot Starter Parent] for more info.
====

Next, we need to tell our application to connect to our PostgreSQL database.
We do this by adding some properties to `src/main/resources/application.properties`:

[source]
----
spring.datasource.url=jdbc:postgresql://localhost/taskdb
spring.datasource.username=postgres
spring.datasource.password=my-secret-pwd
spring.jpa.hibernate.ddl-auto=validate
----

[TIP]
This assumes that we already created a database called `taskdb` in the PostgreSQL database.

[NOTE]
====
If you don't have a PostgreSQL database, you can use H2, which is an embedded database that can run in-memory so you don't have to install anything.

In that case, add this dependency in the `pom.xml`:
[source,xml]
----
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
----

Use this in `application.properties`:
[source]
----
spring.datasource.url=jdbc:h2:mem:tasksdb;MODE=PostgreSQL
----
====

If you now start the application, you should see output similar to this:

[source]
----

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.2.4.RELEASE)

2020-02-20 21:01:38.990  INFO 23191 --- [           main] l.LaravelIntermediateTaskListApplication : Starting LaravelIntermediateTaskListApplication on Wims-MacBook-Pro.local with PID 23191
2020-02-20 21:01:38.997  INFO 23191 --- [           main] l.LaravelIntermediateTaskListApplication : No active profile set, falling back to default profiles: default
2020-02-20 21:01:39.745  INFO 23191 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.

...

2020-02-20 21:01:41.794  INFO 23191 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2020-02-20 21:01:41.800  INFO 23191 --- [           main] l.LaravelIntermediateTaskListApplication : Started LaravelIntermediateTaskListApplication in 3.134 seconds (JVM running for 3.859)
----

If you get an error, carefully check all described steps. Or have a look to https://TODO[this commit] in the example code repository.

We can now check using a database tool that the tables have been created according to our Flyway script:

image::{imagesdir}/2020/02/laravel-intermediate-task-list-02.png[width=500]

There is also the `flyway_schema_history` table.
This is used internally by Flyway to keep track of what migration have already run.

=== Models

Laravel uses https://laravel.com/docs/5.2/eloquent[Eloquent] as ORM (object-relational mapper).
In the Java world, there is a standard called JPA (Java Persistence API) that is similar to that.
As JPA is only an API, you need an implementation as well.
The most known implementation is https://hibernate.org/[Hibernate] and this is what we are going to use here.

To start, we create our `User` class:

[source,java]
----
package com.wimdeblauwe.examples.laravelintermediatetasklist.user;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity //<1>
@Table(name = "task_user") //<2>
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id; //<3>
    private String name;
    private String email;
    private String password;

    protected User() { // <4>

    }

    public User(Long id, String name, String email, String password) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.password = password;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public String getPassword() {
        return password;
    }
}
----
<1> The `@Entity` annotation indicates that this class is the object model for a database table
<2> The `@Table` annotation allows to specify the name of the table in our database.
If we don't specify the annotation at all, the name of the class is used converted to `snake_case`.
<3> The `@Id` and `@GeneratedValue` annotations are used to indicate our `id` field is an auto-increment primary key in the database.
<4> Hibernate requires a no-argument constructor.
We hide from the rest of the application by making it `protected` as our application code should not use that constructor.

We also create the `Task` class:

[source,java]
----
package com.wimdeblauwe.examples.laravelintermediatetasklist.task;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity //<1>
public class Task {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    protected Task() {

    }

    public Task(Long id, String name) {
        this.id = id;
        this.name = name;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }
}
----
<1> We don't have the `@Table` annotation here since the database table is called `task`, which follows the default naming scheme.

[WARNING]
====
Eloquent defaults to plural names for the database tables when deriving the table name from the model.
In Spring Boot, it is singular by default

.Default table name examples
|===
|Model |Eloquent |Spring Boot/Hibernate

|`Task`
|`tasks`
|`task`

|`ProductInfo`
|`product_infos`
|`product_info`
|===
====

=== Relationships between models

Now that our models are defined, we need to link them.
For example, our `User` can have many `Task` instances, while a `Task` is assigned to a single `User`.
Defining a relationship will allow us to fluently walk through our relations like so:

[source,java]
----
User user = repository.findById(1);

for (Task task : user.getTasks()) {
    System.out.println(task.getName());
}
----

The first relation is from `User` to `Task`:

[source,java]
----
public class User {

    ...

    @OneToMany(mappedBy = "user", //<1>
            cascade = CascadeType.ALL, //<2>
            orphanRemoval = true) //<3>
    private Set<Task> tasks;

    ...

    public Set<Task> getTasks() {
        return tasks;
    }

    public void setTasks(Set<Task> tasks) {
        this.tasks = tasks;
    }
}
----
<1> The `@OneToMany` annotation indicates that one `User` has many `Task` objects.
The `mappedBy` property refers to the name of the property in the `Task` class that refers to the `User` class.
<2> `cascade` defines how the persistence of the `Task` objects should be done when saving a `User` in the database.
With `CascadeType.ALL`, we specify that we want all tasks to be saved when we save the `User` object.
<3> `orphanRemoval` indicates that we want all task records removed from the database automatically when a user is removed.
The inverse relation from `Task` to `User` should be coded like this:

[source,java]
----
public class Task {
    ...

    @ManyToOne(fetch = FetchType.LAZY) //<1>
    private User user;

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }
}
----
<1> The `@ManyToOne` annotation indicates that one `Task` is linked to one `User`, but that a `User` can have many `Task` objects.
See https://www.baeldung.com/hibernate-lazy-eager-loading[Eager/Lazy Loading In Hibernate] if you want to know more about the `FetchType.LAZY` value.

Now that our relationships are defined, we can start building our controllers.

== Routing

With Laravel, you use an `app/Http/routes.php` file to link URLs to methods on controllers.
With Spring MVC, we annotate the controller methods with the URLs directly.

For example:

[source,java]
----
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller // <1>
public class RootController {

    @GetMapping("/") // <2>
    public String welcome() {
        return "welcome";
    }
}
----
<.> Class must be annotated with `@Controller` to be picked up by Spring MVC.
<.> The `@GetMapping` annotation indicates that a request on `/` should call this method.

[NOTE]
====
Although not common, it is also possible to define routes in a central place with Spring.
See https://www.baeldung.com/spring-mvc-functional-controllers for more info on that.
====

=== Displaying a view

The controller methods return a `String`, which indicates the server-side view that will be rendered.
With https://www.thymeleaf.org/[Thymeleaf], templates should be put in `src/main/resources/templates`

Since we return `"welcome"` in our `welcome()` method in the `RootController`, we need to create a `src/main/resources/templates/welcome.html` file:

[source,html]
----
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Welcome</title>
</head>
<body>
<h1>Welcome</h1>
<div>
    Your Application's Landing Page.
</div>
</body>
</html>
----

If you now start the application and go to http://localhost:8080, you should see something like this:

image::{imagesdir}/2020/02/laravel-intermediate-task-list-03.png[]

[WARNING]
====
Since Spring Security is in the list of our dependencies (in the `pom.xml` file), it becomes active with a default configuration automatically.
So there will be a default login page.

Use `user` as username and check the logging for the generated password (It will change on each startup of the application)
It is displayed like this in the output:
[source]
----
2020-02-21 16:10:23.323  INFO 26411 --- [           main] .s.s.UserDetailsServiceAutoConfiguration :

Using generated security password: 17536cd3-b0ac-4de6-bd96-a3a0eee40412

----
====

=== Authentication

As stated in the warning above, our application is "secure" by just adding the Spring Security dependency in our Maven project.
However, having only a single user and a password that restarts every time we start the application is hardly convenient for any application.

Let's configure our application to use a fixed password so we can get to know a bit about configuration of Spring Security.
We will create a `WebSecurityConfiguration` class for this:

[source,java]
----
package com.wimdeblauwe.examples.laravelintermediatetasklist.infrastructure.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

@Component // <1>
public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter { // <2>

    @Bean
    public PasswordEncoder passwordEncoder() { // <3>
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth, PasswordEncoder passwordEncoder) throws Exception {
        auth.inMemoryAuthentication() // <4>
            .withUser("user") // <5>
            .password(passwordEncoder.encode("password")) // <6>
            .roles("USER"); // <7>
    }
}
----
<1> The `@Component` annotation instructs Spring to create a Singleton instance of this class when our application starts.
<2> By extending from `WebSecurityConfigurerAdapter`, we can override methods to configure the security
<3> Define what `PasswordEncoder` should be used in our application
<4> We want to "store" our users in-memory (We will switch to using our database later)
<5> Specify the username of the user
<6> Specify the password of the user using the password encoder
<7> Specify the roles of the defined user. We use `USER` here as this is the default role that is needed on secured pages.

If you now restart the application, you should be able to log on using `user`/`password`.

==== Authentication views

Laravel has the `make:auth` Artisan command to generate default registration and login templates, which are really convenient.
There is no such thing in Spring (except for the default login form), so we will need code this ourselves.

Let's start with the login form:

.src/main/resources/templates/login.html
[source,html]
----
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Login</title>
</head>
<body>
<h1>Tasks List - Login</h1>
<div>
    <form th:action="@{/login}" method="post"> <!--1-->
        <div>
            <div>
                Username:
                <input type="text" name="username" id="username"
                       required
                       autofocus>
            </div>
            <div>
                Password:
                <input type="password" name="password"
                       required>
            </div>
            <div>
                <button type="submit">Sign In</button>
            </div>
        </div>
    </form>
</div>
</body>
</html>
----
<.> Define a HTML form that does a `POST` to `/login`

In this template we use a Thymeleaf link URL expression: `@{/login}`
This defines on what URL the `POST` should be done when the form is submitted.

Next, we create the corresponding controller:

[source,java]
----
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

import java.security.Principal;

@Controller
public class UserController {
    @GetMapping("/login") // <1>
    public String login(@AuthenticationPrincipal Principal principal) { // <2>
        if (principal == null) {
            return "login"; // <3>
        } else {
            return "redirect:/"; // <4>
        }
    }
}
----
<.> Map the `GET` request on `/login` to the `login` method.
<.> Inject the authenticated user, if there is already an authenticated user.
Is `null` if there is none.
<.> Show the `login.html` template when there is no authenticated user.
<.> Redirect to the home page if there is already an authenticated user.

Lastly, override the `configure(HttpSecurity http)` method in the `WebSecurityConfiguration` class:

[source,java]
----
@Component
public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {

    ...

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests() // <1>
            .anyRequest() // <1>
            .authenticated() // <1>
            .and()
                .formLogin() // <2>
                .loginPage("/login") // <3>
                .permitAll() // <4>
            .and()
                .logout() // <5>
                .permitAll();
    }
}
----
<1> States that any request should be authenticated
<2> Use form based login
<3> Specify that the login page is available at the `/login` endpoint
<4> Allow all users (also the not authenticated ones) to access the login page
<5> Configure logout

If you now restart the application and go to http://localhost:8080, you will be redirected to http://localhost:8080/login.
Our (ugly ðŸ™ˆ) custom login page will be shown:

image::{imagesdir}/2020/02/laravel-intermediate-task-list-04.png[]

You can log in using `user`/`password` and after that you are redirected to the welcome page.

[NOTE]
====
If you manually access http://localhost:8080/login after you are already logged on, then
you are immediately redirected to the welcome page.
This is due to the redirect we have set up in `UserController`.
====

=== The task controller

To create and retrieve task, we'll need to build a `TaskController`.
Artisan has a command `make:controller` to do this.
With Spring, we just create the class manually:

[source,java]
----
package com.wimdeblauwe.examples.laravelintermediatetasklist.task.web;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
@RequestMapping("/tasks") // <1>
public class TaskController {

    @GetMapping
    public String index() {
        return null;
    }

    @PostMapping // <2>
    public String store() {
        return null;
    }

    @DeleteMapping("/{taskId}") // <3>
    public String destroy(@PathVariable Integer taskId) {
        return null;
    }
}
----
<1> The `RequestMapping` annotation indicates that all methods in this class map to the `/tasks` URL (and below)
<2> Declare a `POST` mapping on the root (below `/tasks`)
<3> Declare a `DELETE` mapping on `/tasks/<taskId>`.
The `<taskId>` part of the URL will be injected as the `taskId` variable in the method.

==== Authenticating All Task Routes

For this application, we want all of our task routes to require an authenticated user.
In other words, the user must be "logged into" the application in order to create a task.
So, we need to restrict access to our task routes to only authenticated users.

In Laravel, you need to add a call to the `middleware` method.
With Spring, we handle authentication centrally in our `WebSecurityConfiguration` class we have created before.
Since we declared there that all routes should be authenticated, there is no extra work to do for our `TaskController`.

=== Building Layouts & Views

The primary part of this application only has a single view which contains a form for adding new tasks as well as a listing of all current tasks.
To help you visualize the view, here is a screenshot of the finished application with basic Bootstrap CSS styling applied:

TODO Add screenshot here

==== Defining The Layout

Almost all web applications share the same layout across pages.
For example, this application has a top navigation bar that would be typically present on every page (if we had more than one).
Laravel makes it easy to share these common features across every page using Blade layouts.

Thymeleaf has a very similar layout feature as well called *Thymeleaf Layout Dialect*.

We need to start with adding the necessairy dependency in our `pom.xml`:

[source,xml]
----
<project>
    <dependencies>
        ...
        <dependency>
            <groupId>nz.net.ultraq.thymeleaf</groupId>
            <artifactId>thymeleaf-layout-dialect</artifactId>
        </dependency>
    </dependencies>
</project>
----

Now we can create our layout template file:

[source,html]
.src/main/resources/templates/layouts/app.html
----
<!DOCTYPE html>
<html lang="en"
      xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"> <!--1-->
<head>
    <title>Tasks</title>

    <!-- Fonts -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css" rel='stylesheet' type='text/css'>
    <link href="https://fonts.googleapis.com/css?family=Lato:100,300,400,700" rel='stylesheet' type='text/css'>

    <!-- Styles -->
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <style>
        body {
            font-family: 'Lato';
        }
        .fa-btn {
            margin-right: 6px;
        }
    </style>
</head>

<body>
<div class="container">
    <nav class="navbar navbar-default">
        <!-- Navbar Contents here (See GitHub sources) -->
    </nav>
</div>

<div layout:fragment="content"> <!--2-->

</div>

<!-- JavaScript -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
</body>
</html>
----
<1> Declare the `layout` namespace
<2> Declare an extension point `content` for the pages using this layout (The `@yield` statement in the blade templates)

==== Defining The Child View

Great, our application layout is finished.
Next, we need to define a view that contains a form to create a new task as well as a table that lists all existing tasks.
Let's define this view in `src/main/resources/task/index.html`, which will correspond to the `index()` method in our `TaskController`.

We'll skip over some of the Bootstrap CSS boilerplate and only focus on the things that matter.
Remember, you can download the full source for this application on https://TODO[GitHub]:

[source,html]
.src/main/resources/templates/task/index.html
----
<!DOCTYPE html>
<html lang="en"
      xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      layout:decorate="~{layouts/app}"> <!--1-->
<body>
<div layout:fragment="content"> <!--2-->
    <div class="panel-body">

        <!-- New Task Form -->
        <form th:action="@{/tasks}" method="POST" class="form-horizontal">

            <!-- Task Name -->
            <div class="form-group">
                <label for="task-name" class="col-sm-3 control-label">Task</label>

                <div class="col-sm-6">
                    <input type="text" name="name" id="task-name" class="form-control">
                </div>
            </div>

            <!-- Add Task Button -->
            <div class="form-group">
                <div class="col-sm-offset-3 col-sm-6">
                    <button type="submit" class="btn btn-default">
                        <i class="fa fa-plus"></i> Add Task
                    </button>
                </div>
            </div>
        </form>
    </div>

    <!-- TODO: Current Tasks -->
</div>
</body>
</html>
----
<1> The `layout:decorate` attribute indicates that this file should be decorated with the layout defined by `layouts/app.html`.
<2> All HTML inside this `div` will put in the `content` section of the layout


Now we have defined a basic layout and view for our application.
Let's go ahead and return this view from the `index()` method of our `TaskController`:

[source,java]
.filename.java
----
@Controller
@RequestMapping("/tasks")
public class TaskController {

    @GetMapping
    public String index() {
        return "task/index"; // <1>
    }

    ...
}
----
<.> Indicate the view that should be used. The path is relative to `src/main/resources/templates`.
Since our `index.html` is located in the `src/main/resources/templates/task` directory, we need to return `task/index` (so without the `.html` extension).

The resulting web page will look like this:

[.image-border]
image::{imagesdir}/2020/02/laravel-intermediate-task-list-05.png[width=400px]

Now that we have our nice layout, we will also update the login page to use this.
Check out the source code for details. The result looks like this:

[.image-border]
image::{imagesdir}/2020/02/laravel-intermediate-task-list-06.png[width=400px]

One thing to note is the error handling if there was a problem to log on:

[.image-border]
image::{imagesdir}/2020/02/laravel-intermediate-task-list-07.png[width=400px]

This is done via this piece of HTML:

[source,html]
----
<div th:if="${param.error}" class="help-block">
    <p class="text-danger">There was an error logging in. Please check your email address and password.</p>
</div>
----

When there is an error, Spring will add the `error` query parameter to the URL.
We can use this in our Thymeleaf template to show an error message.

Next, we're ready to add code to our `POST` `/tasks` route's controller method to handle the incoming form input and add a new task to the database.

== References

* Source code for this blog entry: TODO
* Source code PHP tutorial: https://github.com/laravel/quickstart-intermediate/
