---
title: "Port of the Laravel Intermediate Task List tutorial to Spring Boot with Thymeleaf"
date: 2020-02-17
draft: true
tags: ["thymeleaf", "spring-boot", "laravel"]
---
:source-highlighter: rouge
:rouge-css: style
:rouge-style: github
:imagesdir: /images
:icons: font
:toc: macro
:numbered:
:table-caption!:

https://laravel.com/[Laravel] is a very interesting PHP framework for building web applications.
Their docs have https://laravel.com/docs/5.2/quickstart-intermediate[a nice tutorial] to build a task list to explain many of their concepts.
This blog post basically mirrors that tutorial but shows how to build the same web application using https://spring.io/projects/spring-boot[Spring Boot] and https://www.thymeleaf.org/[Thymeleaf].

<!--more-->

toc::[]

== Installation

=== Prerequisites

The preferred way to install Laravel is to use composer.
For our Spring Boot port, we will be using http://maven.apache.org/[Maven] as our build tool.

Installation of Java and Maven on macOS is very easy if you use https://sdkman.io/[SDKMAN!].
Follow the installation instructions at https://sdkman.io/install to get started.

* Install Java:
+
[source]
----
sdk install java 11.0.5.hs-adpt
----
* Install Maven
+
[source]
----
sdk install maven
----

We need to specify a version for Java since we want to have the current LTS (Long Term Support) version which is 11 at the time of writing.
For Maven, we can just get the latest one (3.6.3 at the time of writing)

To check if both are installed correctly, run:

[source]
----
> mvn --version
Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)
Maven home: /Users/wdb/.sdkman/candidates/maven/current
Java version: 11.0.5, vendor: AdoptOpenJDK, runtime: /Users/wdb/.sdkman/candidates/java/11.0.5.hs-adpt
Default locale: en_BE, platform encoding: UTF-8
OS name: "mac os x", version: "10.15.3", arch: "x86_64", family: "mac"
----

=== Spring installation

With Laravel, the project is created using the following command:

[source]
----
composer create-project laravel/laravel quickstart --prefer-dist
----

Spring Boot has no such command.
Instead, a project is generated via https://start.spring.io.
Open that web page and select the following options:

[cols="20,20,60"]
|===
|Option |Value|Description

|Project
|Maven
|Allows to select the build tool to use. The 2 most widely used options are Maven and Gradle.

|Language
|Java
|Java code runs on the JVM (Java Virtual Machine).
However, there are also other languages that run in the same environment.
https://kotlinlang.org/[Kotlin] and http://groovy-lang.org/[Groovy] are other options that are possible.

|Spring Boot
|2.2.4
|Selection of the Spring Boot version to use.
This also defines what compatible versions of dependencies that will be used.

|Project Metadata
a|* GroupId: `com.wimdeblauwe.examples`
* ArtifactId: `laravel-intermediate-task-list`
|The `groupId:artifactId` defines the "name" of the project.
Don't worry about this too much now, you can always change it later.

|Options
|Java 11
|The "Options" item hides some more advanced options.
For now, the most important to select "Java 11" since that is the version of Java we want to use.

|Dependencies
|Spring Web, Thymeleaf, Spring Data JPA, Flyway Migration, Spring Security
a|Spring Boot is a very modular system.
When creating our project, we need to specify which modules we want to use.
In this case, we need to following 4 modules:

* Spring Web: Web server and routing
* Thymeleaf: HTML templating (similar to Blade)
* Spring Data JPA: Database access (similar to Eloquent)
* Flyway Migration: Database migrations
* Spring Security: Application security
|===

When everything is correctly selected, the page should look similar to this:

image::{imagesdir}/2020/02/laravel-intermediate-task-list-01.png[]

Press the 'Generate' button and a zip file with your project will be downloaded.
Unzip the project and open it in your favorite IDE (I use https://www.jetbrains.com/idea/[IntelliJ IDEA])

== Prepping the database

=== Database migrations

Laravel uses the Artisan CLI to generate PHP code that defines the database migration.
With Spring Boot, we will be using https://flywaydb.org/[Flyway].

Most important differences:

* Flyway uses plain SQL script to define the migrations (although you can use Java classes as well if you want)
* There is no code to reverse the migrations (like the `down()` method in Laravel migrations) by default.
It is possible with https://flywaydb.org/download/[Flyway Pro] to use https://flywaydb.org/documentation/migrations#undo-migrations[Undo Migrations] if you require this.

Spring Boot assumes Flyway migrations are put in `src/main/resources/db/migration` by default.

After creating those directories, we can add our first migration file:

.V1.0__init.sql
[source,sql]
----
CREATE TABLE task_user
(
    id       SERIAL       NOT NULL,
    name     VARCHAR(255) NOT NULL,
    email    VARCHAR(255) NOT NULL,
    password VARCHAR(255) NOT NULL,
    PRIMARY KEY (id)
);

CREATE TABLE task
(
    id      SERIAL       NOT NULL,
    user_id SERIAL       NOT NULL,
    name    VARCHAR(255) NOT NULL,
    PRIMARY KEY (id)
);

ALTER TABLE task
    ADD CONSTRAINT FK_task_to_user FOREIGN KEY (user_id) REFERENCES task_user;
----

See the https://flywaydb.org/documentation/migrations#naming[Naming] chapter in the Flyway documentation for more information
about how the name of the SQL file influences the order of the migrations.

[NOTE]
====
We are using `SERIAL` to get auto-incremented primary keys.
This is easiest now to get started, but it https://vladmihalcea.com/postgresql-serial-column-hibernate-identity/[might not always be the most performant option].
====

The database for this application will be https://www.postgresql.org/[PostgreSQL].
Java needs a JDBC driver to talk to the database.

We can add the PostgreSQL driver by adding a dependency in the `pom.xml` file that was generated by the Spring Boot website.
Go to https://start.spring.io again and go straight for the "Dependencies" section.
Type "PostgreSQL" and select the "PostgreSQL Driver" dependency that pops up.
Now use the 'Explore' button to view the `pom.xml` that would be generated if we would create a project.
In the popup, you will find the dependency section:

[source,xml]
----
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>
----

Add this XML snippet to your own `pom.xml` inside the `<dependencies>` node.

Next, we need to tell our application to connect to our PostgreSQL database.
We do this by adding some properties to `src/main/resources/application.properties`:

[source]
----
spring.datasource.url=jdbc:postgresql://localhost/taskdb
spring.datasource.username=postgres
spring.datasource.password=my-secret-pwd
spring.jpa.hibernate.ddl-auto=validate
----

[TIP]
This assumes that we already created a database called `taskdb` in the PostgreSQL database.

[NOTE]
====
If you don't have a PostgreSQL database, you can use H2, which is an embedded database that can run in-memory so you don't have to install anything.

In that case, add this dependency in the `pom.xml`:
[source,xml]
----
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
----

Use this in `application.properties`:
[source]
----
spring.datasource.url=jdbc:h2:mem:tasksdb;MODE=PostgreSQL
----
====

If you now start the application, you should see output similar to this:

[source]
----

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.2.4.RELEASE)

2020-02-20 21:01:38.990  INFO 23191 --- [           main] l.LaravelIntermediateTaskListApplication : Starting LaravelIntermediateTaskListApplication on Wims-MacBook-Pro.local with PID 23191
2020-02-20 21:01:38.997  INFO 23191 --- [           main] l.LaravelIntermediateTaskListApplication : No active profile set, falling back to default profiles: default
2020-02-20 21:01:39.745  INFO 23191 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.

...

2020-02-20 21:01:41.794  INFO 23191 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2020-02-20 21:01:41.800  INFO 23191 --- [           main] l.LaravelIntermediateTaskListApplication : Started LaravelIntermediateTaskListApplication in 3.134 seconds (JVM running for 3.859)
----

If you get an error, carefully check all described steps. Or have a look to https://TODO[this commit] in the example code repository.

We can now check using a database tool that the tables have been created according to our Flyway script:

image::{imagesdir}/2020/02/laravel-intermediate-task-list-02.png[width=500]

There is also the `flyway_schema_history` table.
This is used internally by Flyway to keep track of what migration have already run.

=== Models

Laravel uses https://laravel.com/docs/5.2/eloquent[Eloquent] as ORM (object-relational mapper).
In the Java world, there is a standard called JPA (Java Persistence API) that is similar to that.
As JPA is only an API, you need an implementation as well.
The most known implementation is https://hibernate.org/[Hibernate] and this is what we are going to use here.

To start, we create our `User` class:

[source,java]
----
package com.wimdeblauwe.examples.laravelintermediatetasklist.user;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity //<1>
@Table(name = "task_user") //<2>
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id; //<3>
    private String name;
    private String email;
    private String password;

    protected User() { // <4>

    }

    public User(Long id, String name, String email, String password) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.password = password;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public String getPassword() {
        return password;
    }
}
----
<1> The `@Entity` annotation indicates that this class is the object model for a database table
<2> The `@Table` annotation allows to specify the name of the table in our database.
If we don't specify the annotation at all, the name of the class is used converted to `snake_case`.
<3> The `@Id` and `@GeneratedValue` annotations are used to indicate our `id` field is an auto-increment primary key in the database.
<4> Hibernate requires a no-argument constructor.
We hide from the rest of the application by making it `protected` as our application code should not use that constructor.

We also create the `Task` class:

[source,java]
----
package com.wimdeblauwe.examples.laravelintermediatetasklist.task;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity //<1>
public class Task {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    protected Task() {

    }

    public Task(Long id, String name) {
        this.id = id;
        this.name = name;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }
}
----
<1> We don't have the `@Table` annotation here since the database table is called `task`, which follows the default naming scheme.

[WARNING]
====
Eloquent defaults to plural names for the database tables when deriving the table name from the model.
In Spring Boot, it is singular by default

.Default table name examples
|===
|Model |Eloquent |Spring Boot/Hibernate

|`Task`
|`tasks`
|`task`

|`ProductInfo`
|`product_infos`
|`product_info`
|===
====

=== Relationships between models

Now that our models are defined, we need to link them.
For example, our `User` can have many `Task` instances, while a `Task` is assigned to a single `User`.
Defining a relationship will allow us to fluently walk through our relations like so:

[source,java]
----
User user = repository.findById(1);

for (Task task : user.getTasks()) {
    System.out.println(task.getName());
}
----

The first relation is from `User` to `Task`:

[source,java]
----
public class User {

    ...

    @OneToMany(mappedBy = "user", //<1>
            cascade = CascadeType.ALL, //<2>
            orphanRemoval = true) //<3>
    private Set<Task> tasks;

    ...

    public Set<Task> getTasks() {
        return tasks;
    }

    public void setTasks(Set<Task> tasks) {
        this.tasks = tasks;
    }
}
----
<1> The `@OneToMany` annotation indicates that one `User` has many `Task` objects.
The `mappedBy` property refers to the name of the property in the `Task` class that refers to the `User` class.
<2> `cascade` defines how the persistence of the `Task` objects should be done when saving a `User` in the database.
With `CascadeType.ALL`, we specify that we want all tasks to be saved when we save the `User` object.
<3> `orphanRemoval` indicates that we want all task records removed from the database automatically when a user is removed.
The inverse relation from `Task` to `User` should be coded like this:

[source,java]
----
public class Task {
    ...

    @ManyToOne(fetch = FetchType.LAZY) //<1>
    private User user;

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }
}
----
<1> The `@ManyToOne` annotation indicates that one `Task` is linked to one `User`, but that a `User` can have many `Task` objects.
See https://www.baeldung.com/hibernate-lazy-eager-loading[Eager/Lazy Loading In Hibernate] if you want to know more about the `FetchType.LAZY` value.

Now that our relationships are defined, we can start building our controllers.

== Routing

With Laravel, you use an `app/Http/routes.php` file to link URLs to methods on controllers.
With Spring MVC, we annotate the controller methods with the URLs directly.

For example:

[source,java]
----
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller // <1>
public class RootController {

    @GetMapping("/") // <2>
    public String welcome() {
        return "welcome";
    }
}
----
<.> Class must be annotated with `@Controller` to be picked up by Spring MVC.
<.> The `@GetMapping` annotation indicates that a request on `/` should call this method.

[NOTE]
====
Although not common, it is also possible to define routes in a central place with Spring.
See https://www.baeldung.com/spring-mvc-functional-controllers for more info on that.
====

=== Displaying a view

The controller methods return a `String`, which indicates the server-side view that will be rendered.
With https://www.thymeleaf.org/[Thymeleaf], templates should be put in `src/main/resources/templates`

Since we return `"welcome"` in our `welcome()` method in the `RootController`, we need to create a `src/main/resources/templates/welcome.html` file:

[source,html]
----
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Welcome</title>
</head>
<body>
<h1>Welcome</h1>
<div>
    Your Application's Landing Page.
</div>
</body>
</html>
----

If you now start the application and go to http://localhost:8080, you should see something like this:

image::{imagesdir}/2020/02/laravel-intermediate-task-list-03.png[]

[WARNING]
====
Since Spring Security is in the list of our dependencies (in the `pom.xml` file), it becomes active with a default configuration automatically.
So there will be a default login page.

Use `user` as username and check the logging for the generated password (It will change on each startup of the application)
It is displayed like this in the output:
[source]
----
2020-02-21 16:10:23.323  INFO 26411 --- [           main] .s.s.UserDetailsServiceAutoConfiguration :

Using generated security password: 17536cd3-b0ac-4de6-bd96-a3a0eee40412

----
====

=== Authentication

As stated in the warning above, our application is "secure" by just adding the Spring Security dependency in our Maven project.
However, having only a single user and a password that restarts every time we start the application is hardly convenient for any application.

Let's configure our application to use a fixed password so we can get to know a bit about configuration of Spring Security.
We will create a `WebSecurityConfiguration` class for this:

[source,java]
----
package com.wimdeblauwe.examples.laravelintermediatetasklist.infrastructure.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

@Component // <1>
public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter { // <2>

    @Bean
    public PasswordEncoder passwordEncoder() { // <3>
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth, PasswordEncoder passwordEncoder) throws Exception {
        auth.inMemoryAuthentication() // <4>
            .withUser("user") // <5>
            .password(passwordEncoder.encode("password")) // <6>
            .roles("USER"); // <7>
    }
}
----
<1> The `@Component` annotation instructs Spring to create a Singleton instance of this class when our application starts.
<2> By extending from `WebSecurityConfigurerAdapter`, we can override methods to configure the security
<3> Define what `PasswordEncoder` should be used in our application
<4> We want to "store" our users in-memory (We will switch to using our database later)
<5> Specify the username of the user
<6> Specify the password of the user using the password encoder
<7> Specify the roles of the defined user. We use `USER` here as this is the default role that is needed on secured pages.

If you now restart the application, you should be able to log on using `user`/`password`.

==== Authentication views

Laravel has the `make:auth` Artisan command to generate default registration and login templates, which are really convenient.
There is no such thing in Spring (except for the default login form), so we will need code this ourselves.

Let's start with the login form:

.src/main/resources/templates/login.html
[source,html]
----
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Login</title>
</head>
<body>
<h1>Tasks List - Login</h1>
<div>
    <form th:action="@{/login}" method="post"> <!--1-->
        <div>
            <div>
                Username:
                <input type="text" name="username" id="username"
                       required
                       autofocus>
            </div>
            <div>
                Password:
                <input type="password" name="password"
                       required>
            </div>
            <div>
                <button type="submit">Sign In</button>
            </div>
        </div>
    </form>
</div>
</body>
</html>
----
<.> Define a HTML form that does a `POST` to `/login`

In this template we use a Thymeleaf link URL expression: `@{/login}`
This defines on what URL the `POST` should be done when the form is submitted.

Next, we create the corresponding controller:

[source,java]
----
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

import java.security.Principal;

@Controller
public class UserController {
    @GetMapping("/login") // <1>
    public String login(@AuthenticationPrincipal Principal principal) { // <2>
        if (principal == null) {
            return "login"; // <3>
        } else {
            return "redirect:/"; // <4>
        }
    }
}
----
<.> Map the `GET` request on `/login` to the `login` method.
<.> Inject the authenticated user, if there is already an authenticated user.
Is `null` if there is none.
<.> Show the `login.html` template when there is no authenticated user.
<.> Redirect to the home page if there is already an authenticated user.

Lastly, override the `configure(HttpSecurity http)` method in the `WebSecurityConfiguration` class:

[source,java]
----
@Component
public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {

    ...

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests() // <1>
            .anyRequest() // <1>
            .authenticated() // <1>
            .and()
                .formLogin() // <2>
                .loginPage("/login") // <3>
                .permitAll() // <4>
            .and()
                .logout() // <5>
                .permitAll();
    }
}
----
<1> States that any request should be authenticated
<2> Use form based login
<3> Specify that the login page is available at the `/login` endpoint
<4> Allow all users (also the not authenticated ones) to access the login page
<5> Configure logout

If you now restart the application and go to http://localhost:8080, you will be redirected to http://localhost:8080/login.
Our (ugly ðŸ™ˆ) custom login page will be shown:

image::{imagesdir}/2020/02/laravel-intermediate-task-list-04.png[]

You can log in using `user`/`password` and after that you are redirected to the welcome page.

[NOTE]
====
If you manually access http://localhost:8080/login after you are already logged on, then
you are immediately redirected to the welcome page.
This is due to the redirect we have set up in `UserController`.
====

== References

* Source code for this blog entry: TODO
* Source code PHP tutorial: https://github.com/laravel/quickstart-intermediate/
